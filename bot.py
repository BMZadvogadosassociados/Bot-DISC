@bot.command(name="ajuda")
async def ajuda(ctx):
    embed = discord.Embed(title="üìñ Comandos", color=discord.Color.green())
    embed.add_field(name="**üé≠ Sistema de Cargos**", value="", inline=False)
    embed.add_field(name="!cargo", value="Configurar cargo autom√°tico", inline=True)
    embed.add_field(name="!setcargo", value="Cargo para mencionar", inline=True)
    
    embed.add_field(name="**üé´ Sistema de Tickets**", value="", inline=Falseimport discord
from discord.ext import commands
from discord import TextStyle
from discord.ui import View, Modal, TextInput, Button, Select
from discord import SelectOption
from math import ceil
import asyncio
import logging
import os
import json
import sys
import socket
import time
from datetime import datetime
from dotenv import load_dotenv

# ===== SINGLE INSTANCE CONTROL =====
def get_single_instance_lock():
    """Cria um socket para garantir que apenas uma inst√¢ncia rode."""
    try:
        # Criar um socket que ser√° usado como lock
        lock_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        lock_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        # Tentar fazer bind em uma porta espec√≠fica
        # Se outra inst√¢ncia estiver rodando, isso falhar√°
        lock_socket.bind(('127.0.0.1', 65432))  # Porta espec√≠fica para este bot
        lock_socket.listen(1)
        
        print("‚úÖ Inst√¢ncia √∫nica confirmada - Bot pode iniciar")
        return lock_socket
        
    except OSError:
        print("‚ùå ERRO: J√° existe uma inst√¢ncia do bot rodando!")
        print("üîç Para verificar processos ativos:")
        print("   Linux/Mac: ps aux | grep python")
        print("   Windows: tasklist | findstr python")
        print("üõë Encerrando para evitar duplica√ß√£o...")
        sys.exit(1)

# ===== INITIALIZE LOGGING =====
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    datefmt="%d/%m/%Y %H:%M:%S"
)
logger = logging.getLogger('discord')
logger.setLevel(logging.INFO)

# Criar lock de inst√¢ncia √∫nica ANTES de tudo
lock_socket = get_single_instance_lock()

# ===== BOT SETUP =====
intents = discord.Intents.default()
intents.members = True
intents.message_content = True
intents.voice_states = True

bot = commands.Bot(command_prefix="!", intents=intents)

# ===== DATA STORAGE =====
auto_roles = {}
ticket_response_channels = {}
mention_roles = {}
sugestao_channels = {}
ticket_categories = {}
ticket_support_roles = {}
log_channels = {}  # Canal de logs por servidor

# Flag para controlar views
views_registered = False

# ===== CONFIGURA√á√ïES DOS TIPOS DE SUPORTE =====
SUPPORT_TYPES = {
    "tecnico": {
        "name": "Suporte T√©cnico",
        "emoji": "üñ•Ô∏è",
        "role_id": 1359194954756264120,
        "description": "Para problemas t√©cnicos e TI"
    },
    "kommo": {
        "name": "Suporte Kommo",
        "emoji": "üì±",
        "role_id": 1373012855271719003,
        "description": "Para quest√µes do sistema Kommo"
    },
    "rh": {
        "name": "Suporte RH",
        "emoji": "üë•",
        "role_id": 1359505353653489694,
        "description": "Para quest√µes de Recursos Humanos"
    },
    "gerencia": {
        "name": "Suporte Ger√™ncia",
        "emoji": "üíº",
        "role_id": 1359504498048893070,
        "description": "Para quest√µes gerenciais"
    }
}

# ===== DATA MANAGEMENT =====
def salvar_dados():
    dados = {
        "auto_roles": auto_roles,
        "ticket_response_channels": ticket_response_channels,
        "mention_roles": mention_roles,
        "sugestao_channels": sugestao_channels,
        "ticket_categories": ticket_categories,
        "ticket_support_roles": ticket_support_roles,
        "log_channels": log_channels,
    }
    
    try:
        with open("dados_servidor.json", "w", encoding="utf-8") as f:
            json.dump(dados, f, indent=4, ensure_ascii=False)
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao salvar dados: {e}")

def carregar_dados():
    try:
        if os.path.exists("dados_servidor.json"):
            with open("dados_servidor.json", "r", encoding="utf-8") as f:
                dados = json.load(f)
                auto_roles.update(dados.get("auto_roles", {}))
                ticket_response_channels.update(dados.get("ticket_response_channels", {}))
                mention_roles.update(dados.get("mention_roles", {}))
                sugestao_channels.update(dados.get("sugestao_channels", {}))
                ticket_categories.update(dados.get("ticket_categories", {}))
                ticket_support_roles.update(dados.get("ticket_support_roles", {}))
                log_channels.update(dados.get("log_channels", {}))
                print("‚úÖ Dados carregados com sucesso")
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao carregar dados: {e}")

# ===== SISTEMA DE LOGS =====
async def enviar_log(guild, titulo, descricao, cor=discord.Color.blue(), campos=None, thumbnail=None):
    """Envia log para o canal configurado ou servidor de logs"""
    try:
        guild_id = str(guild.id)
        log_channel_id = log_channels.get(guild_id)
        
        if not log_channel_id:
            return  # Sem canal configurado
            
        log_channel = bot.get_channel(log_channel_id)
        if not log_channel:
            return  # Canal n√£o encontrado
            
        embed = discord.Embed(
            title=titulo,
            description=descricao,
            color=cor,
            timestamp=datetime.now()
        )
        
        if campos:
            for campo in campos:
                embed.add_field(
                    name=campo.get("name", "Campo"),
                    value=campo.get("value", "Valor"),
                    inline=campo.get("inline", True)
                )
        
        if thumbnail:
            embed.set_thumbnail(url=thumbnail)
            
        embed.set_footer(text=f"Servidor: {guild.name}", icon_url=guild.icon.url if guild.icon else None)
        
        await log_channel.send(embed=embed)
        
    except Exception as e:
        print(f"‚ùå Erro ao enviar log: {e}")

# ===== TICKET MODAL =====
class TicketModal(Modal, title="Solicitar Cargo"):
    nome = TextInput(label="Nome", placeholder="Digite seu nome completo", style=TextStyle.short)
    cargo = TextInput(label="Setor / Cargo desejado", placeholder="Ex: Financeiro, RH...", style=TextStyle.paragraph)

    async def on_submit(self, interaction: discord.Interaction):
        mod_channel_id = ticket_response_channels.get(str(interaction.guild.id))
        mod_channel = bot.get_channel(mod_channel_id)
        cargo_id = mention_roles.get(str(interaction.guild.id))

        try:
            await interaction.user.edit(nick=self.nome.value)
        except discord.Forbidden:
            await interaction.response.send_message("‚ùå N√£o consegui alterar seu apelido", ephemeral=True)
            return

        if not mod_channel:
            await interaction.response.send_message("‚ùå Canal n√£o configurado", ephemeral=True)
            return

        embed = discord.Embed(title="üìâ Novo Pedido de Cargo", color=discord.Color.blurple())
        embed.add_field(name="Usu√°rio", value=interaction.user.mention, inline=False)
        embed.add_field(name="Cargo desejado", value=self.cargo.value, inline=False)
        embed.set_footer(text=f"ID: {interaction.user.id}")

        mention = f"<@&{cargo_id}>" if cargo_id else ""
        await mod_channel.send(content=mention, embed=embed)
        await interaction.response.send_message("‚úÖ Pedido enviado!", ephemeral=True)

class TicketButton(Button):
    def __init__(self):
        super().__init__(label="Solicitar cargo", emoji="üì¨", style=discord.ButtonStyle.secondary, custom_id="ticket_button")

    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_modal(TicketModal())

class TicketButtonView(View):
    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(TicketButton())

# ===== TICKET SUPPORT SYSTEM =====
class TicketSupportModal(Modal, title="Abrir Ticket de Suporte"):
    assunto = TextInput(label="Assunto", placeholder="Descreva brevemente seu problema", style=TextStyle.short)
    descricao = TextInput(label="Descri√ß√£o detalhada", placeholder="Explique seu problema em detalhes...", style=TextStyle.paragraph)

    def __init__(self, support_type):
        super().__init__()
        self.support_type = support_type
        self.title = f"Ticket - {SUPPORT_TYPES[support_type]['name']}"

    async def on_submit(self, interaction: discord.Interaction):
        guild_id = str(interaction.guild.id)
        category_id = ticket_categories.get(guild_id)
        
        if not category_id:
            await interaction.response.send_message("‚ùå Sistema n√£o configurado", ephemeral=True)
            return
            
        category = interaction.guild.get_channel(category_id)
        
        if not category:
            await interaction.response.send_message("‚ùå Categoria n√£o encontrada", ephemeral=True)
            return

        # Obter informa√ß√µes do tipo de suporte
        support_info = SUPPORT_TYPES[self.support_type]
        support_role = interaction.guild.get_role(support_info['role_id'])

        ticket_name = f"ticket-{self.support_type}-{interaction.user.name.lower().replace(' ', '-')}"
        
        overwrites = {
            interaction.guild.default_role: discord.PermissionOverwrite(read_messages=False),
            interaction.user: discord.PermissionOverwrite(read_messages=True, send_messages=True),
            interaction.guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True, manage_messages=True)
        }
        
        if support_role:
            overwrites[support_role] = discord.PermissionOverwrite(read_messages=True, send_messages=True, manage_messages=True)

        try:
            ticket_channel = await interaction.guild.create_text_channel(
                name=ticket_name,
                category=category,
                overwrites=overwrites,
                topic=f"Ticket de {interaction.user.display_name} - {support_info['name']}"
            )
            
            embed = discord.Embed(
                title=f"üé´ {support_info['name']}",
                color=discord.Color.blue(),
                timestamp=datetime.now()
            )
            embed.add_field(name="üë§ Usu√°rio", value=interaction.user.mention, inline=True)
            embed.add_field(name="üìù Assunto", value=self.assunto.value, inline=True)
            embed.add_field(name="üè∑Ô∏è Tipo", value=f"{support_info['emoji']} {support_info['name']}", inline=True)
            embed.add_field(name="üìÑ Descri√ß√£o", value=self.descricao.value, inline=False)
            embed.set_footer(text=f"ID do usu√°rio: {interaction.user.id}")
            embed.set_thumbnail(url=interaction.user.display_avatar.url)
            
            close_view = TicketCloseView()
            
            mention_text = f"{interaction.user.mention}"
            if support_role:
                mention_text += f" <@&{support_info['role_id']}>"
                
            await ticket_channel.send(
                content=f"{mention_text}\n\n**Ol√° {interaction.user.mention}!** üëã\nSeu ticket de **{support_info['name']}** foi criado. Nossa equipe ir√° ajudar em breve.",
                embed=embed,
                view=close_view
            )
            
            # Log da cria√ß√£o do ticket
            await enviar_log(
                interaction.guild,
                "üé´ Ticket Criado",
                f"Novo ticket de suporte foi aberto",
                discord.Color.green(),
                [
                    {"name": "üë§ Usu√°rio", "value": f"{interaction.user.mention} ({interaction.user.id})", "inline": True},
                    {"name": "üè∑Ô∏è Tipo", "value": f"{support_info['emoji']} {support_info['name']}", "inline": True},
                    {"name": "üìù Assunto", "value": self.assunto.value[:100] + ("..." if len(self.assunto.value) > 100 else ""), "inline": False},
                    {"name": "üìç Canal", "value": ticket_channel.mention, "inline": True}
                ],
                interaction.user.display_avatar.url
            )
            
            await interaction.response.send_message(f"‚úÖ Ticket criado: {ticket_channel.mention}", ephemeral=True)
            
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Erro: {str(e)}", ephemeral=True)

class SupportTypeSelect(Select):
    def __init__(self):
        options = []
        for key, info in SUPPORT_TYPES.items():
            options.append(SelectOption(
                label=info['name'],
                description=info['description'],
                emoji=info['emoji'],
                value=key
            ))
        
        super().__init__(
            placeholder="Selecione o tipo de suporte...",
            options=options,
            custom_id="support_type_select"
        )

    async def callback(self, interaction: discord.Interaction):
        support_type = self.values[0]
        modal = TicketSupportModal(support_type)
        await interaction.response.send_modal(modal)

class TicketSupportView(View):
    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(SupportTypeSelect())

# ===== CLOSE TICKET SYSTEM =====
class TicketCloseView(View):
    def __init__(self):
        super().__init__(timeout=None)
        
    @discord.ui.button(label="üîí Fechar Ticket", style=discord.ButtonStyle.danger, custom_id="close_ticket_button")
    async def close_ticket(self, interaction: discord.Interaction, button: Button):
        user_id = None
        
        try:
            async for message in interaction.channel.history(limit=20, oldest_first=True):
                if message.embeds and message.author == interaction.guild.me:
                    embed = message.embeds[0]
                    if embed.footer and "ID do usu√°rio:" in embed.footer.text:
                        user_id = int(embed.footer.text.split("ID do usu√°rio: ")[1])
                        break
        except:
            pass
        
        # Verificar se o usu√°rio tem permiss√£o (dono do ticket, admin, ou qualquer cargo de suporte)
        has_permission = (
            interaction.user.id == user_id or 
            interaction.user.guild_permissions.manage_channels or
            any(role.id in [info['role_id'] for info in SUPPORT_TYPES.values()] for role in interaction.user.roles)
        )
        
        if not has_permission:
            await interaction.response.send_message("‚ùå Sem permiss√£o", ephemeral=True)
            return
            
        confirm_view = ConfirmCloseView()
        await interaction.response.send_message("‚ö†Ô∏è Fechar ticket?", view=confirm_view, ephemeral=True)

class ConfirmCloseView(View):
    def __init__(self):
        super().__init__(timeout=30)
        
    @discord.ui.button(label="‚úÖ Sim", style=discord.ButtonStyle.danger)
    async def confirm_close(self, interaction: discord.Interaction, button: Button):
        try:
            # Coletar informa√ß√µes do ticket antes de fechar
            ticket_info = {"user": "Desconhecido", "type": "Desconhecido"}
            
            async for message in interaction.channel.history(limit=20, oldest_first=True):
                if message.embeds and message.author == interaction.guild.me:
                    embed = message.embeds[0]
                    if "üë§ Usu√°rio" in embed.description or any("üë§ Usu√°rio" in field.name for field in embed.fields):
                        for field in embed.fields:
                            if field.name == "üë§ Usu√°rio":
                                user_mention = field.value.split()[0]
                                ticket_info["user"] = user_mention
                            elif field.name == "üè∑Ô∏è Tipo":
                                ticket_info["type"] = field.value
                        break
            
            channel_name = interaction.channel.name
            
            await interaction.response.send_message("üîí Fechando em 3s...")
            
            # Log do fechamento do ticket
            await enviar_log(
                interaction.guild,
                "üîí Ticket Fechado",
                f"Ticket foi fechado",
                discord.Color.red(),
                [
                    {"name": "üë§ Usuario do Ticket", "value": ticket_info["user"], "inline": True},
                    {"name": "üè∑Ô∏è Tipo", "value": ticket_info["type"], "inline": True},
                    {"name": "üîí Fechado por", "value": f"{interaction.user.mention} ({interaction.user.id})", "inline": True},
                    {"name": "üìç Canal", "value": f"#{channel_name}", "inline": True}
                ],
                interaction.user.display_avatar.url
            )
            
            await asyncio.sleep(3)
            await interaction.channel.delete(reason=f"Ticket fechado por {interaction.user.name}")
        except Exception as e:
            print(f"Erro ao fechar ticket: {e}")
            
    @discord.ui.button(label="‚ùå Cancelar", style=discord.ButtonStyle.secondary)
    async def cancel_close(self, interaction: discord.Interaction, button: Button):
        await interaction.response.send_message("‚úÖ Cancelado", ephemeral=True)

# ===== SUGGESTION SYSTEM =====
class SugestaoModal(Modal, title="Envie sua sugest√£o"):
    mensagem = TextInput(label="Escreva aqui", style=TextStyle.paragraph)

    async def on_submit(self, interaction):
        canal_id = sugestao_channels.get(str(interaction.guild.id))
        canal = bot.get_channel(canal_id)
        if canal:
            embed = discord.Embed(title="üì¢ Sugest√£o An√¥nima", description=self.mensagem.value, color=discord.Color.orange())
            embed.set_footer(text="Enviado anonimamente")
            await canal.send(embed=embed)
        await interaction.response.send_message("‚úÖ Enviado!", ephemeral=True)

class SugestaoButton(Button):
    def __init__(self):
        super().__init__(label="Enviar sugest√£o", emoji="üí°", style=discord.ButtonStyle.secondary, custom_id="sugestao_button")

    async def callback(self, interaction):
        await interaction.response.send_modal(SugestaoModal())

class SugestaoView(View):
    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(SugestaoButton())

# ===== BOT EVENTS =====
@bot.event
async def on_ready():
    global views_registered
    
    if not views_registered:
        print(f"‚úÖ Bot conectado: {bot.user}")
        print(f"üîß Registrando views persistentes...")
        
        try:
            bot.add_view(TicketButtonView())
            bot.add_view(SugestaoView())
            bot.add_view(TicketSupportView())
            bot.add_view(TicketCloseView())
            views_registered = True
            print("‚úÖ Views registradas com sucesso")
        except Exception as e:
            print(f"‚ùå Erro ao registrar views: {e}")
    else:
        print("‚ÑπÔ∏è Bot reconectado - Views j√° registradas")

@bot.event
async def on_member_join(member):
    role_id = auto_roles.get(str(member.guild.id))
    if role_id:
        role = member.guild.get_role(role_id)
        if role:
            try:
                await member.add_roles(role)
                print(f"‚úÖ Cargo {role.name} dado para {member.name}")
                
                # Log de entrada do membro
                await enviar_log(
                    member.guild,
                    "üëã Membro Entrou",
                    f"Novo membro entrou no servidor",
                    discord.Color.green(),
                    [
                        {"name": "üë§ Usu√°rio", "value": f"{member.mention} ({member.id})", "inline": True},
                        {"name": "üìÖ Conta Criada", "value": f"<t:{int(member.created_at.timestamp())}:R>", "inline": True},
                        {"name": "üé≠ Cargo Autom√°tico", "value": role.mention if role else "Nenhum", "inline": True}
                    ],
                    member.display_avatar.url
                )
            except Exception as e:
                print(f"‚ùå Erro ao dar cargo: {e}")

@bot.event
async def on_member_remove(member):
    # Log de sa√≠da do membro
    await enviar_log(
        member.guild,
        "üëã Membro Saiu",
        f"Membro saiu do servidor",
        discord.Color.orange(),
        [
            {"name": "üë§ Usu√°rio", "value": f"{member.name}#{member.discriminator} ({member.id})", "inline": True},
            {"name": "üìÖ Entrou em", "value": f"<t:{int(member.joined_at.timestamp())}:R>" if member.joined_at else "Desconhecido", "inline": True},
            {"name": "üé≠ Cargos", "value": ", ".join([role.name for role in member.roles[1:]][:5]) or "Nenhum", "inline": False}
        ],
        member.display_avatar.url
    )

@bot.event
async def on_message_delete(message):
    if message.author.bot:
        return
        
    # Log de mensagem deletada
    await enviar_log(
        message.guild,
        "üóëÔ∏è Mensagem Deletada",
        f"Mensagem foi deletada",
        discord.Color.red(),
        [
            {"name": "üë§ Autor", "value": f"{message.author.mention} ({message.author.id})", "inline": True},
            {"name": "üìç Canal", "value": f"{message.channel.mention}", "inline": True},
            {"name": "üìù Conte√∫do", "value": message.content[:500] + ("..." if len(message.content) > 500 else "") if message.content else "*Sem conte√∫do de texto*", "inline": False},
            {"name": "üìÖ Enviada em", "value": f"<t:{int(message.created_at.timestamp())}:R>", "inline": True}
        ],
        message.author.display_avatar.url
    )

@bot.event
async def on_message_edit(before, after):
    if before.author.bot or before.content == after.content:
        return
        
    # Log de mensagem editada
    await enviar_log(
        before.guild,
        "‚úèÔ∏è Mensagem Editada",
        f"Mensagem foi editada",
        discord.Color.yellow(),
        [
            {"name": "üë§ Autor", "value": f"{before.author.mention} ({before.author.id})", "inline": True},
            {"name": "üìç Canal", "value": f"{before.channel.mention}", "inline": True},
            {"name": "üìù Antes", "value": before.content[:300] + ("..." if len(before.content) > 300 else "") if before.content else "*Sem conte√∫do*", "inline": False},
            {"name": "üìù Depois", "value": after.content[:300] + ("..." if len(after.content) > 300 else "") if after.content else "*Sem conte√∫do*", "inline": False}
        ],
        before.author.display_avatar.url
    )

@bot.event
async def on_voice_state_update(member, before, after):
    # Log de movimenta√ß√£o de voz
    if before.channel != after.channel:
        if before.channel is None:  # Entrou em call
            await enviar_log(
                member.guild,
                "üîä Entrou em Call",
                f"Membro entrou em canal de voz",
                discord.Color.green(),
                [
                    {"name": "üë§ Usu√°rio", "value": f"{member.mention} ({member.id})", "inline": True},
                    {"name": "üìç Canal", "value": f"üîä {after.channel.name}", "inline": True},
                    {"name": "üë• Pessoas no Canal", "value": str(len(after.channel.members)), "inline": True}
                ],
                member.display_avatar.url
            )
        elif after.channel is None:  # Saiu da call
            await enviar_log(
                member.guild,
                "üîá Saiu de Call",
                f"Membro saiu de canal de voz",
                discord.Color.red(),
                [
                    {"name": "üë§ Usu√°rio", "value": f"{member.mention} ({member.id})", "inline": True},
                    {"name": "üìç Canal", "value": f"üîä {before.channel.name}", "inline": True},
                    {"name": "üë• Pessoas Restantes", "value": str(len(before.channel.members)), "inline": True}
                ],
                member.display_avatar.url
            )
        else:  # Mudou de canal
            await enviar_log(
                member.guild,
                "üîÑ Mudou de Call",
                f"Membro mudou de canal de voz",
                discord.Color.blue(),
                [
                    {"name": "üë§ Usu√°rio", "value": f"{member.mention} ({member.id})", "inline": True},
                    {"name": "üìç De", "value": f"üîä {before.channel.name}", "inline": True},
                    {"name": "üìç Para", "value": f"üîä {after.channel.name}", "inline": True}
                ],
                member.display_avatar.url
            )

@bot.event
async def on_guild_channel_delete(channel):
    # Log de canal deletado
    await enviar_log(
        channel.guild,
        "üóëÔ∏è Canal Deletado",
        f"Canal foi deletado",
        discord.Color.red(),
        [
            {"name": "üìç Nome", "value": f"#{channel.name}", "inline": True},
            {"name": "üè∑Ô∏è Tipo", "value": str(channel.type).title(), "inline": True},
            {"name": "üìÅ Categoria", "value": channel.category.name if channel.category else "Nenhuma", "inline": True}
        ]
    )

@bot.event
async def on_guild_channel_create(channel):
    # Log de canal criado
    await enviar_log(
        channel.guild,
        "‚ûï Canal Criado",
        f"Novo canal foi criado",
        discord.Color.green(),
        [
            {"name": "üìç Nome", "value": f"{channel.mention}", "inline": True},
            {"name": "üè∑Ô∏è Tipo", "value": str(channel.type).title(), "inline": True},
            {"name": "üìÅ Categoria", "value": channel.category.name if channel.category else "Nenhuma", "inline": True}
        ]
    )

@bot.event
async def on_member_update(before, after):
    # Log de mudan√ßas no membro (nick, cargos)
    if before.nick != after.nick:
        await enviar_log(
            after.guild,
            "‚úèÔ∏è Apelido Alterado",
            f"Apelido de membro foi alterado",
            discord.Color.blue(),
            [
                {"name": "üë§ Usu√°rio", "value": f"{after.mention} ({after.id})", "inline": True},
                {"name": "üìù Antes", "value": before.nick or before.name, "inline": True},
                {"name": "üìù Depois", "value": after.nick or after.name, "inline": True}
            ],
            after.display_avatar.url
        )
    
    # Verificar mudan√ßas de cargos
    if before.roles != after.roles:
        added_roles = [role for role in after.roles if role not in before.roles]
        removed_roles = [role for role in before.roles if role not in after.roles]
        
        if added_roles:
            await enviar_log(
                after.guild,
                "‚ûï Cargo Adicionado",
                f"Cargo foi adicionado ao membro",
                discord.Color.green(),
                [
                    {"name": "üë§ Usu√°rio", "value": f"{after.mention} ({after.id})", "inline": True},
                    {"name": "üé≠ Cargos Adicionados", "value": ", ".join([role.mention for role in added_roles]), "inline": False}
                ],
                after.display_avatar.url
            )
        
        if removed_roles:
            await enviar_log(
                after.guild,
                "‚ûñ Cargo Removido",
                f"Cargo foi removido do membro",
                discord.Color.red(),
                [
                    {"name": "üë§ Usu√°rio", "value": f"{after.mention} ({after.id})", "inline": True},
                    {"name": "üé≠ Cargos Removidos", "value": ", ".join([role.name for role in removed_roles]), "inline": False}
                ],
                after.display_avatar.url
            )

@bot.event
async def on_command_completion(ctx):
    salvar_dados()

@bot.event
async def on_guild_join(guild):
    salvar_dados()

@bot.event
async def on_guild_remove(guild):
    guild_id = str(guild.id)
    auto_roles.pop(guild_id, None)
    ticket_response_channels.pop(guild_id, None)
    mention_roles.pop(guild_id, None)
    sugestao_channels.pop(guild_id, None)
    ticket_categories.pop(guild_id, None)
    ticket_support_roles.pop(guild_id, None)
    log_channels.pop(guild_id, None)
    salvar_dados()

# ===== COMMANDS =====
@bot.command(aliases=["cargos"])
@commands.has_permissions(administrator=True)
async def cargo(ctx):
    roles = [r for r in ctx.guild.roles if not r.is_bot_managed() and r.name != "@everyone"]
    options = [SelectOption(label=r.name[:100], value=str(r.id)) for r in roles[:25]]

    if not options:
        await ctx.send("‚ö†Ô∏è Nenhum cargo encontrado")
        return

    class RoleSelect(Select):
        def __init__(self):
            super().__init__(placeholder="Selecione o cargo autom√°tico", options=options)

        async def callback(self, interaction: discord.Interaction):
            role_id = int(self.values[0])
            auto_roles[str(ctx.guild.id)] = role_id
            salvar_dados()
            role = ctx.guild.get_role(role_id)
            await interaction.response.send_message(f"‚úÖ Cargo configurado: **{role.name}**", ephemeral=True)

    view = View()
    view.add_item(RoleSelect())
    await ctx.send("üë• Selecione o cargo autom√°tico:", view=view)

@bot.command()
@commands.has_permissions(administrator=True)
async def setlogs(ctx):
    """Configura o canal ou servidor de logs"""
    
    embed1 = discord.Embed(
        title="üìä Configura√ß√£o de Logs",
        description="**Escolha uma op√ß√£o:**\n\n"
                   "üè† **Mesmo Servidor** - Canal no servidor atual\n"
                   "üåê **Outro Servidor** - Canal em servidor diferente\n\n"
                   "**Digite:**\n"
                   "`1` - Para canal no mesmo servidor\n"
                   "`2` - Para canal em outro servidor",
        color=discord.Color.blue()
    )
    
    await ctx.send(embed=embed1)
    
    def check_option(msg):
        return msg.author == ctx.author and msg.channel == ctx.channel and msg.content in ['1', '2']
    
    try:
        msg = await bot.wait_for('message', check=check_option, timeout=30.0)
        option = msg.content
        
        if option == '1':
            # Canal no mesmo servidor
            channels = [c for c in ctx.guild.text_channels if c.permissions_for(ctx.guild.me).send_messages]
            if not channels:
                await ctx.send("‚ùå Nenhum canal dispon√≠vel")
                return
                
            channel_list = "\n".join([f"`{i+1}.` {c.mention}" for i, c in enumerate(channels[:15])])
            
            embed2 = discord.Embed(
                title="üìç Selecionar Canal de Logs",
                description=f"**Canais dispon√≠veis:**\n{channel_list}\n\n**Digite o n√∫mero do canal:**",
                color=discord.Color.green()
            )
            
            await ctx.send(embed=embed2)
            
            def check_channel(msg):
                return msg.author == ctx.author and msg.channel == ctx.channel and msg.content.isdigit()
            
            try:
                msg2 = await bot.wait_for('message', check=check_channel, timeout=30.0)
                channel_num = int(msg2.content) - 1
                
                if 0 <= channel_num < len(channels):
                    selected_channel = channels[channel_num]
                    log_channels[str(ctx.guild.id)] = selected_channel.id
                    salvar_dados()
                    
                    await ctx.send(f"‚úÖ **Canal de logs configurado:** {selected_channel.mention}")
                else:
                    await ctx.send("‚ùå N√∫mero inv√°lido")
                    
            except asyncio.TimeoutError:
                await ctx.send("‚è∞ Tempo esgotado")
                
        elif option == '2':
            # Canal em outro servidor
            embed2 = discord.Embed(
                title="üåê Canal em Outro Servidor",
                description="**Para configurar logs em outro servidor:**\n\n"
                           "1Ô∏è‚É£ Copie o **ID do canal** de destino\n"
                           "2Ô∏è‚É£ Certifique-se que o bot est√° no servidor\n"
                           "3Ô∏è‚É£ Digite o ID do canal aqui\n\n"
                           "**üí° Como pegar ID do canal:**\n"
                           "‚Ä¢ Ative o Modo Desenvolvedor no Discord\n"
                           "‚Ä¢ Clique com bot√£o direito no canal\n"
                           "‚Ä¢ Selecione 'Copiar ID'",
                color=discord.Color.orange()
            )
            
            await ctx.send(embed=embed2)
            
            def check_channel_id(msg):
                return msg.author == ctx.author and msg.channel == ctx.channel and msg.content.isdigit()
            
            try:
                msg2 = await bot.wait_for('message', check=check_channel_id, timeout=60.0)
                channel_id = int(msg2.content)
                
                # Verificar se o canal existe e se o bot tem acesso
                target_channel = bot.get_channel(channel_id)
                
                if target_channel:
                    try:
                        # Testar se consegue enviar mensagem
                        test_embed = discord.Embed(
                            title="üß™ Teste de Logs",
                            description=f"Logs do servidor **{ctx.guild.name}** configurados com sucesso!",
                            color=discord.Color.green()
                        )
                        await target_channel.send(embed=test_embed)
                        
                        log_channels[str(ctx.guild.id)] = channel_id
                        salvar_dados()
                        
                        await ctx.send(f"‚úÖ **Canal de logs configurado:** `{target_channel.name}` em `{target_channel.guild.name}`")
                        
                    except discord.Forbidden:
                        await ctx.send("‚ùå Sem permiss√£o para enviar no canal especificado")
                    except Exception as e:
                        await ctx.send(f"‚ùå Erro ao testar o canal: {str(e)}")
                else:
                    await ctx.send("‚ùå Canal n√£o encontrado. Verifique se o ID est√° correto e se o bot est√° no servidor.")
                    
            except asyncio.TimeoutError:
                await ctx.send("‚è∞ Tempo esgotado")
            except ValueError:
                await ctx.send("‚ùå ID inv√°lido")
                
    except asyncio.TimeoutError:
        await ctx.send("‚è∞ Tempo esgotado")

@bot.command()
@commands.has_permissions(administrator=True)
async def testlog(ctx):
    """Testa o sistema de logs"""
    await enviar_log(
        ctx.guild,
        "üß™ Teste de Sistema",
        "Este √© um teste do sistema de logs",
        discord.Color.purple(),
        [
            {"name": "üë§ Testado por", "value": f"{ctx.author.mention}", "inline": True},
            {"name": "üìç Canal", "value": f"{ctx.channel.mention}", "inline": True},
            {"name": "‚è∞ Status", "value": "‚úÖ Sistema Funcionando", "inline": True}
        ],
        ctx.author.display_avatar.url
    )
    
    await ctx.send("üß™ **Teste enviado!** Verifique o canal de logs.")

@bot.command()
@commands.has_permissions(administrator=True)
async def removelogs(ctx):
    """Remove a configura√ß√£o de logs"""
    guild_id = str(ctx.guild.id)
    
    if guild_id in log_channels:
        log_channels.pop(guild_id)
        salvar_dados()
        await ctx.send("‚úÖ **Sistema de logs desativado**")
    else:
        await ctx.send("‚ùå **Sistema de logs n√£o estava configurado**")
async def setcargo(ctx):
    roles = [r for r in ctx.guild.roles if not r.is_bot_managed() and r.name != "@everyone"]
    options = [SelectOption(label=r.name[:100], value=str(r.id)) for r in roles[:25]]

    if not options:
        await ctx.send("‚ö†Ô∏è Nenhum cargo encontrado")
        return

    class MentionRoleSelect(Select):
        def __init__(self):
            super().__init__(placeholder="Cargo para mencionar nos tickets", options=options)

        async def callback(self, interaction: discord.Interaction):
            role_id = int(self.values[0])
            mention_roles[str(ctx.guild.id)] = role_id
            salvar_dados()
            role = ctx.guild.get_role(role_id)
            await interaction.response.send_message(f"üìå Cargo mencionado: **{role.name}**", ephemeral=True)

    view = View()
    view.add_item(MentionRoleSelect())
    await ctx.send("üî£ Selecione o cargo para mencionar:", view=view)

@bot.command()
@commands.has_permissions(administrator=True)
async def ticket(ctx):
    channels = [c for c in ctx.guild.text_channels if c.permissions_for(ctx.guild.me).send_messages]
    if not channels:
        await ctx.send("‚ùå Nenhum canal dispon√≠vel")
        return

    options = [SelectOption(label=c.name[:100], value=str(c.id)) for c in channels[:25]]

    class ChannelSelect(Select):
        def __init__(self):
            super().__init__(placeholder="Canal para tickets", options=options)

        async def callback(self, interaction: discord.Interaction):
            channel_id = int(self.values[0])
            ticket_response_channels[str(ctx.guild.id)] = channel_id
            salvar_dados()
            await interaction.response.send_message(f"‚úÖ Canal configurado: <#{channel_id}>", ephemeral=True)
            await ctx.send("üìâ Solicite seu cargo:", view=TicketButtonView())

    view = View()
    view.add_item(ChannelSelect())
    await ctx.send("üìå Escolha o canal:", view=view)

@bot.command()
@commands.has_permissions(administrator=True)
async def setupticket(ctx):
    """Configura o sistema de tickets em duas etapas."""
    guild_id = str(ctx.guild.id)
    categories = ctx.guild.categories
    
    if not categories:
        await ctx.send("‚ùå **Erro:** N√£o h√° categorias no servidor.\nüìÅ Crie uma categoria primeiro usando as configura√ß√µes do servidor.")
        return
        
    # Criar lista de categorias
    category_list = "\n".join([f"`{i+1}.` {cat.name}" for i, cat in enumerate(categories[:10])])
    
    embed = discord.Embed(
        title="üìÅ Configura√ß√£o de Tickets - Categoria",
        description=f"**Categorias dispon√≠veis:**\n{category_list}\n\n**Digite o n√∫mero da categoria desejada:**",
        color=discord.Color.blue()
    )
    
    await ctx.send(embed=embed)
    
    def check_category(msg):
        return msg.author == ctx.author and msg.channel == ctx.channel and msg.content.isdigit()
    
    try:
        # Aguardar resposta do usu√°rio para categoria
        msg = await bot.wait_for('message', check=check_category, timeout=30.0)
        category_num = int(msg.content) - 1
        
        if 0 <= category_num < len(categories):
            selected_category = categories[category_num]
            ticket_categories[guild_id] = selected_category.id
            salvar_dados()
            
            # Confirma√ß√£o final
            success_embed = discord.Embed(
                title="‚úÖ Sistema de Tickets Configurado!",
                color=discord.Color.green()
            )
            success_embed.add_field(name="üìÅ Categoria", value=selected_category.name, inline=True)
            success_embed.add_field(name="üéØ Tipos Dispon√≠veis", value="\n".join([f"{info['emoji']} {info['name']}" for info in SUPPORT_TYPES.values()]), inline=False)
            success_embed.add_field(name="üìã Pr√≥ximo Passo", value="Use `!ticketpanel` para criar o painel", inline=False)
            
            await ctx.send(embed=success_embed)
            
        else:
            await ctx.send("‚ùå **Erro:** N√∫mero de categoria inv√°lido. Use `!setupticket` novamente.")
            
    except asyncio.TimeoutError:
        await ctx.send("‚è∞ **Tempo esgotado!** Use `!setupticket` novamente.")
    except ValueError:
        await ctx.send("‚ùå **Erro:** Digite apenas n√∫meros. Use `!setupticket` novamente.")

@bot.command()
@commands.has_permissions(administrator=True)
async def ticketpanel(ctx):
    guild_id = str(ctx.guild.id)
    
    if guild_id not in ticket_categories:
        await ctx.send("‚ùå Use `!setupticket` primeiro")
        return
        
    embed = discord.Embed(
        title="üé´ Sistema de Suporte",
        description="**Precisa de ajuda?** Selecione o tipo de suporte!\n\n"
                   "**üìã Tipos dispon√≠veis:**\n"
                   f"{SUPPORT_TYPES['tecnico']['emoji']} **{SUPPORT_TYPES['tecnico']['name']}** - {SUPPORT_TYPES['tecnico']['description']}\n"
                   f"{SUPPORT_TYPES['kommo']['emoji']} **{SUPPORT_TYPES['kommo']['name']}** - {SUPPORT_TYPES['kommo']['description']}\n"
                   f"{SUPPORT_TYPES['rh']['emoji']} **{SUPPORT_TYPES['rh']['name']}** - {SUPPORT_TYPES['rh']['description']}\n"
                   f"{SUPPORT_TYPES['gerencia']['emoji']} **{SUPPORT_TYPES['gerencia']['name']}** - {SUPPORT_TYPES['gerencia']['description']}\n\n"
                   "‚úÖ **Como funciona:**\n"
                   "‚Ä¢ Selecione o tipo de suporte\n"
                   "‚Ä¢ Preencha o formul√°rio\n"
                   "‚Ä¢ Canal privado ser√° criado\n"
                   "‚Ä¢ Equipe especializada te ajudar√°\n\n"
                   "‚ö†Ô∏è **Use apenas para suporte real**",
        color=discord.Color.blue()
    )
    embed.set_footer(text="Selecione o tipo de suporte no menu abaixo")
    
    await ctx.send(embed=embed, view=TicketSupportView())

@bot.command()
@commands.has_permissions(administrator=True)
async def reclamacao(ctx):
    canais = [c for c in ctx.guild.text_channels if c.permissions_for(ctx.guild.me).send_messages]
    options = [SelectOption(label=c.name[:100], value=str(c.id)) for c in canais[:25]]

    class CanalSelect(Select):
        def __init__(self):
            super().__init__(placeholder="Canal para sugest√µes", options=options)

        async def callback(self, interaction):
            canal_id = int(self.values[0])
            sugestao_channels[str(ctx.guild.id)] = canal_id
            salvar_dados()
            await interaction.response.send_message("‚úÖ Canal configurado!", ephemeral=True)
            await ctx.send("**üìú Envie sugest√µes anonimamente:**", view=SugestaoView())

    view = View()
    view.add_item(CanalSelect())
    await ctx.send("üîπ Escolha o canal:", view=view)

@bot.command()
@commands.has_permissions(administrator=True)
async def clear(ctx):
    class ConfirmarLimpeza(Button):
        def __init__(self):
            super().__init__(label="Sim, limpar!", style=discord.ButtonStyle.danger)

        async def callback(self, interaction: discord.Interaction):
            if interaction.user != ctx.author:
                await interaction.response.send_message("‚ùå Apenas o autor pode confirmar", ephemeral=True)
                return

            await interaction.response.send_message("üßπ Limpando...")
            await asyncio.sleep(2)
            await ctx.channel.purge()
            
            aviso = await ctx.send("‚úÖ Canal limpo!")
            await asyncio.sleep(3)
            await aviso.delete()

    view = View()
    view.add_item(ConfirmarLimpeza())
    await ctx.send("‚ö†Ô∏è Limpar todas as mensagens?", view=view)

@bot.command()
async def ping(ctx):
    await ctx.send(f"üèì Pong! Lat√™ncia: `{round(bot.latency * 1000)}ms`")

@bot.command()
async def status(ctx):
    embed = discord.Embed(title="ü§ñ Status do Bot", color=discord.Color.green())
    embed.add_field(name="üìä Status", value="‚úÖ Online", inline=True)
    embed.add_field(name="üèì Ping", value=f"{round(bot.latency * 1000)}ms", inline=True)
    embed.add_field(name="üè† Servidores", value=len(bot.guilds), inline=True)
    embed.add_field(name="üë• Usu√°rios", value=len(bot.users), inline=True)
    embed.add_field(name="üìã Views", value="‚úÖ Ativas" if views_registered else "‚ùå Inativas", inline=True)
    embed.add_field(name="üîí Inst√¢ncia", value="‚úÖ √önica", inline=True)
    
    await ctx.send(embed=embed)

@bot.command(name="ajuda")
async def ajuda(ctx):
    embed = discord.Embed(title="üìñ Comandos do Bot", color=discord.Color.green())
    
    embed.add_field(name="**üé≠ Sistema de Cargos**", value="", inline=False)
    embed.add_field(name="!cargo", value="Configurar cargo autom√°tico", inline=True)
    embed.add_field(name="!setcargo", value="Cargo para mencionar", inline=True)
    
    embed.add_field(name="**üé´ Sistema de Tickets**", value="", inline=False)
    embed.add_field(name="!ticket", value="Sistema de pedidos de cargo", inline=True)
    embed.add_field(name="!setupticket", value="Configurar sistema de suporte", inline=True)
    embed.add_field(name="!ticketpanel", value="Criar painel de tickets", inline=True)
    
    embed.add_field(name="**üí° Sistema de Sugest√µes**", value="", inline=False)
    embed.add_field(name="!reclamacao", value="Configurar sugest√µes an√¥nimas", inline=True)
    
    embed.add_field(name="**üìä Sistema de Logs**", value="", inline=False)
    embed.add_field(name="!setlogs", value="Configurar canal de logs", inline=True)
    embed.add_field(name="!testlog", value="Testar sistema de logs", inline=True)
    embed.add_field(name="!removelogs", value="Desativar logs", inline=True)
    
    embed.add_field(name="**üõ†Ô∏è Utilit√°rios**", value="", inline=False)
    embed.add_field(name="!clear", value="Limpar canal", inline=True)
    embed.add_field(name="!ping", value="Verificar lat√™ncia", inline=True)
    embed.add_field(name="!status", value="Status do bot", inline=True)
    
    embed.set_footer(text="Use !comando para executar ‚Ä¢ Apenas administradores podem usar a maioria dos comandos")
    
    await ctx.send(embed=embed)

# ===== ERROR HANDLING =====
@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.MissingPermissions):
        await ctx.send("‚ùå Sem permiss√£o para este comando")
    elif isinstance(error, commands.CommandNotFound):
        pass
    else:
        print(f"Erro: {error}")

# ===== CLEANUP ON EXIT =====
def cleanup_on_exit():
    """Limpa recursos ao sair."""
    try:
        if 'lock_socket' in globals():
            lock_socket.close()
        print("üßπ Recursos limpos")
    except:
        pass

import atexit
atexit.register(cleanup_on_exit)

# ===== MAIN =====
if __name__ == "__main__":
    try:
        print("üöÄ Iniciando Bot Bmz Server...")
        print(f"üîí PID: {os.getpid()}")
        
        # Carregar dados
        carregar_dados()
        
        # Carregar token
        load_dotenv()
        TOKEN = os.getenv("DISCORD_TOKEN")
        
        if not TOKEN:
            print("‚ùå Token n√£o encontrado no .env")
            sys.exit(1)
        
        # Iniciar bot
        bot.run(TOKEN)
        
    except KeyboardInterrupt:
        print("\nüõë Bot interrompido pelo usu√°rio")
    except Exception as e:
        print(f"‚ùå Erro fatal: {e}")
    finally:
        cleanup_on_exit()
        sys.exit(0)
